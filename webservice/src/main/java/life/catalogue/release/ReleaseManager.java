package life.catalogue.release;

import life.catalogue.WsServerConfig;
import life.catalogue.api.model.DatasetImport;
import life.catalogue.api.model.User;
import life.catalogue.concurrent.NamedThreadFactory;
import life.catalogue.dao.DatasetDao;
import life.catalogue.dao.DatasetImportDao;
import life.catalogue.dao.NameDao;
import life.catalogue.doi.DoiUpdater;
import life.catalogue.doi.service.DoiService;
import life.catalogue.es.NameUsageIndexService;
import life.catalogue.exporter.ExportManager;
import life.catalogue.img.ImageService;

import java.util.Optional;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

import javax.validation.Validator;

import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.ibatis.session.SqlSessionFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ReleaseManager {
  private static final Logger LOG = LoggerFactory.getLogger(ReleaseManager.class);
  private static final ThreadPoolExecutor RELEASE_EXEC = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS,
      new ArrayBlockingQueue(1), new NamedThreadFactory("col-release"), new ThreadPoolExecutor.DiscardPolicy());

  private final ExportManager exportManager;
  private final DatasetImportDao diDao;
  private final DatasetDao dDao;
  private final NameDao nDao;
  private final NameUsageIndexService indexService;
  private final DoiService doiService;
  private final DoiUpdater doiUpdater;
  private final SqlSessionFactory factory;
  private final ImageService imageService;
  private final CloseableHttpClient client;
  private final Validator validator;
  private final WsServerConfig cfg;
  private AbstractProjectCopy job;

  public ReleaseManager(CloseableHttpClient client, DatasetImportDao diDao, DatasetDao dDao, NameDao nDao, ExportManager exportManager, NameUsageIndexService indexService,
                        ImageService imageService, DoiService doiService, DoiUpdater doiUpdater, SqlSessionFactory factory, Validator validator, WsServerConfig cfg) {
    this.client = client;
    this.exportManager = exportManager;
    this.diDao = diDao;
    this.dDao = dDao;
    this.nDao = nDao;
    this.indexService = indexService;
    this.imageService = imageService;
    this.doiService = doiService;
    this.doiUpdater = doiUpdater;
    this.factory = factory;
    this.validator = validator;
    this.cfg = cfg;
  }

  /**
   * @return newly created dataset key of the release
   */
  public Integer release(int datasetKey, User user) {
    return execute(() -> buildRelease(datasetKey, user.getKey()));
  }

  /**
   * @return newly created dataset key of the copy
   */
  public Integer duplicate(int datasetKey, User user) {
    return execute(() -> buildDuplication(datasetKey, user.getKey()));
  }

  /**
   * @return new dataset key generated by the job
   * @throws IllegalArgumentException
   */
  private Integer execute(Supplier<AbstractProjectCopy> jobSupplier) throws IllegalArgumentException {
    if (job != null) {
      throw new IllegalArgumentException(job.getClass().getSimpleName() + " "+ job.getDatasetKey() + " to " + job.getNewDatasetKey() + " is already running");
    }

    job = jobSupplier.get();
    final int key = job.getNewDatasetKey();

    CompletableFuture.runAsync(job, RELEASE_EXEC)
      .exceptionally(ex -> {
        LOG.error("Failed to run {} on dataset {} to dataset {}", job.getClass().getSimpleName(), job.getDatasetKey(), job.getNewDatasetKey(), ex);
        return null;
      })
      .thenApply(x -> {
        // clear release reference when job is done
        job = null;
        return x;
      });
    return key;
  }

  public Optional<DatasetImport> getMetrics() {
    return job == null ? Optional.empty() : Optional.of(job.getMetrics());
  }


  /**
   * Release the catalogue into a new dataset
   * @param projectKey the draft catalogue to be released, e.g. 3 for the CoL draft
   *
   * @throws IllegalArgumentException if the dataset is not managed
   */
  public ProjectRelease buildRelease(final int projectKey, final int userKey) {
    return new ProjectRelease(factory, indexService, diDao, dDao, nDao, imageService, projectKey, userKey, cfg, client, exportManager, doiService, doiUpdater, validator);
  }

  /**
   * Creates a duplicate of a managed project
   * @param projectKey the managed dataset to be copied
   *
   * @throws IllegalArgumentException if the dataset is not managed
   */
  public ProjectDuplication buildDuplication(int projectKey, int userKey) {
    return new ProjectDuplication(factory, indexService, diDao, dDao, validator, projectKey, userKey);
  }

}
