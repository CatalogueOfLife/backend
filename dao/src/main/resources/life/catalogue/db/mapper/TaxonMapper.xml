<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="life.catalogue.db.mapper.TaxonMapper">


  <sql id="taxonCols">
    <include refid="life.catalogue.db.mapper.NameUsageMapper.usageCols"/>,
    ${alias}.scrutinizer AS ${prefix}scrutinizer,
    ${alias}.scrutinizer_date AS ${prefix}scrutinizer_date,
    ${alias}.extinct AS ${prefix}extinct,
    ${alias}.temporal_range_start AS ${prefix}temporal_range_start,
    ${alias}.temporal_range_end AS ${prefix}temporal_range_end,
    ${alias}.environments AS ${prefix}environments,
    ${alias}.link AS ${prefix}link
  </sql>

  <sql id="SELECT">
    <include refid="taxonCols">
      <property name="alias" value="u"/>
      <property name="prefix" value=""/>
    </include>,
    r.citation AS according_to,
    <include refid="life.catalogue.db.mapper.NameMapper.nameCols">
      <property name="alias" value="n"/>
      <property name="prefix" value="n_"/>
    </include>,
    (SELECT count(*) FROM name_usage WHERE dataset_key=u.dataset_key AND parent_id=u.id) AS child_count
  </sql>

  <sql id="COLS">
    <include refid="life.catalogue.db.mapper.NameUsageMapper.COLS"/>,
    scrutinizer,
    scrutinizer_date,
    extinct,
    temporal_range_start,
    temporal_range_end,
    environments,
    link
  </sql>

  <sql id="PROPS">
    <include refid="life.catalogue.db.mapper.NameUsageMapper.PROPS"/>,
    #{scrutinizer},
    #{scrutinizerDate},
    #{extinct},
    #{temporalRangeStart},
    #{temporalRangeEnd},
    #{environments, typeHandler=life.catalogue.db.type.EnvironmentSetTypeHandler},
    #{link, typeHandler=life.catalogue.db.type.UriTypeHandler}
  </sql>

  <sql id="FROM">
    name_usage u
      JOIN name n ON n.dataset_key=u.dataset_key AND n.id=u.name_id
      LEFT JOIN reference r ON r.dataset_key=u.dataset_key AND r.id=u.according_to_id
  </sql>

  <resultMap id="taxonResultMap" type="Taxon" autoMapping="true">
    <id property="id" column="id"/>
    <result property="environments" column="environments" typeHandler="life.catalogue.db.type.EnvironmentSetTypeHandler"/>
    <association property="name" javaType="Name" resultMap="life.catalogue.db.mapper.NameMapper.nameResultMap" columnPrefix="n_"/>
  </resultMap>

  <resultMap id="taxonCountResultMap" type="TaxonSectorCountMap" autoMapping="false">
    <id property="id" column="id"/>
    <result property="count" column="dataset_sectors"/>
  </resultMap>


  <select id="count" resultType="integer">
    SELECT count(*) FROM name_usage
    WHERE dataset_key=#{datasetKey} AND NOT is_synonym
  </select>

  <select id="countChildren" resultType="integer">
    SELECT count(*) FROM name_usage
    WHERE dataset_key=#{key.datasetKey} AND parent_id=#{key.id} AND NOT is_synonym
  </select>

  <select id="countChildrenWithRank" resultType="integer">
    SELECT count(*)
    FROM name_usage u JOIN name n ON n.dataset_key=u.dataset_key AND n.id=u.name_id
    WHERE u.dataset_key=#{key.datasetKey} AND u.parent_id=#{key.id} AND NOT u.is_synonym AND n.rank=#{rank}::rank
  </select>

  <select id="countChildrenBelowRank" resultType="integer">
    SELECT count(*)
    FROM name_usage u JOIN name n ON n.dataset_key=u.dataset_key AND n.id=u.name_id
    WHERE u.dataset_key=#{key.datasetKey} AND u.parent_id=#{key.id} AND NOT u.is_synonym and n.rank > #{rank}::rank
  </select>

  <select id="countRoot" resultType="integer">
    SELECT count(*)
    FROM name_usage
    WHERE dataset_key=#{datasetKey} AND parent_id IS NULL AND NOT is_synonym
  </select>

  <select id="list" resultMap="taxonResultMap">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE u.dataset_key=#{datasetKey} AND NOT u.is_synonym
    ORDER BY id
    <include refid="life.catalogue.db.Common.limit"/>
  </select>

  <select id="listRoot" resultMap="taxonResultMap">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE u.dataset_key=#{datasetKey} AND u.parent_id IS NULL AND NOT u.is_synonym
    ORDER BY id
    <include refid="life.catalogue.db.Common.limit"/>
  </select>

  <select id="listRootIds" resultType="string">
    SELECT id
    FROM name_usage
    WHERE dataset_key=#{datasetKey} AND parent_id IS NULL AND NOT is_synonym
    ORDER BY id
  </select>

  <select id="listByIds" resultMap="taxonResultMap">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE u.dataset_key=#{datasetKey} AND u.id IN
    <foreach item="k" index="idx" collection="ids" open="(" separator="," close=")">#{k}</foreach>
  </select>

  <select id="children" resultMap="taxonResultMap">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE u.dataset_key=#{key.datasetKey} AND  u.parent_id = #{key.id} AND NOT u.is_synonym
    <if test="rank != null">
      AND n.rank > #{rank}::rank
    </if>
    ORDER BY n.rank, n.scientific_name
    <include refid="life.catalogue.db.Common.limit"/>
  </select>

  <select id="classification" resultMap="taxonResultMap">
    WITH RECURSIVE x AS(
      SELECT <include refid="SELECT"/>
      FROM <include refid="FROM"/>
      WHERE u.dataset_key=#{key.datasetKey} AND u.id = #{key.id}
    UNION
      SELECT <include refid="SELECT"/>
      FROM <include refid="FROM"/>, x
      WHERE u.dataset_key=#{key.datasetKey} AND u.id = x.parent_id
    )
    SELECT *
    FROM x
    WHERE x.id != #{key.id}
  </select>

  <select id="classificationSimple" parameterType="map" resultType="SimpleName">
    WITH RECURSIVE cl AS (
      SELECT u.id, u.parent_id, n.scientific_name as name, n.authorship, n.rank
      FROM <include refid="FROM"/>
      WHERE u.dataset_key=#{key.datasetKey} AND u.id = #{key.id}
    UNION
      SELECT u.id, u.parent_id, n.scientific_name, n.authorship, n.rank
      FROM <include refid="FROM"/>, cl
      WHERE u.dataset_key=#{key.datasetKey} AND u.id = cl.parent_id
    )
    SELECT *
    FROM cl
    WHERE cl.id != #{key.id}
  </select>

  <select id="getCounts" resultMap="taxonCountResultMap">
    SELECT id, dataset_sectors
    FROM name_usage
    WHERE dataset_key=#{key.datasetKey} AND id = #{key.id} AND NOT is_synonym
  </select>

  <select id="classificationCounts" resultMap="taxonCountResultMap">
    WITH RECURSIVE x AS(
      SELECT id, parent_id, dataset_sectors
      FROM name_usage u
      WHERE u.dataset_key=#{key.datasetKey} AND u.id = #{key.id}
    UNION
      SELECT u.id, u.parent_id, u.dataset_sectors
      FROM name_usage u, x
      WHERE u.dataset_key=#{key.datasetKey} AND u.id = x.parent_id
    )
    SELECT id, dataset_sectors
    FROM x
  </select>

  <select id="get" resultMap="taxonResultMap" flushCache="true">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE u.dataset_key=#{key.datasetKey} AND u.id = #{key.id} AND NOT u.is_synonym
  </select>

  <select id="processDataset" parameterType="map" resultMap="taxonResultMap" resultOrdered="true" fetchSize="10000" resultSetType="FORWARD_ONLY">
    SELECT <include refid="SELECT"/>
    FROM <include refid="FROM"/>
    WHERE u.dataset_key=#{datasetKey} AND NOT u.is_synonym
  </select>

  <insert id="create" parameterType="Taxon" useGeneratedKeys="false" keyProperty="id">
    INSERT INTO name_usage
    (id,<include refid="COLS"/>, created, modified)
    VALUES (#{id},<include refid="PROPS"/>, now(), now())
  </insert>

  <update id="update" parameterType="Taxon" keyProperty="id">
    UPDATE name_usage
    SET (<include refid="COLS"/>, created, modified)
      = (<include refid="PROPS"/>, now(), now())
    WHERE dataset_key=#{datasetKey} AND id = #{id}
  </update>

  <delete id="delete" parameterType="map">
    DELETE FROM name_usage
    WHERE dataset_key=#{key.datasetKey} AND id = #{key.id} AND NOT is_synonym
  </delete>

  <delete id="deleteByDataset" parameterType="map">
    DELETE FROM name_usage
    WHERE dataset_key=#{datasetKey}
  </delete>

  <update id="incDatasetSectorCount">
    WITH RECURSIVE x AS (
      SELECT u.id, u.parent_id
      FROM name_usage u
      WHERE u.dataset_key=#{key.datasetKey} AND u.id = #{key.id}
    UNION
      SELECT u.id, u.parent_id
      FROM name_usage u, x
      WHERE u.dataset_key=#{key.datasetKey} AND u.id = x.parent_id
    )
    UPDATE name_usage
    SET dataset_sectors = CASE coalesce((dataset_sectors->'${dkey}')::int, 0) + ${delta}
    WHEN 0 THEN
      dataset_sectors - '${dkey}'
    ELSE
      jsonb_set( coalesce(dataset_sectors, '{}'::jsonb), '{"${dkey}"}',
        to_jsonb( coalesce( (dataset_sectors->'${dkey}')::int, 0) + ${delta} ), true
      )
    END
    WHERE dataset_key=#{key.datasetKey} AND id IN (SELECT id FROM x)
  </update>

  <update id="updateDatasetSectorCount">
    UPDATE name_usage
    SET dataset_sectors = to_jsonb( #{count, typeHandler=life.catalogue.db.type.FastutilIntIntHandler}::jsonb )
    WHERE dataset_key=#{key.datasetKey} AND id = #{key.id}
  </update>

  <update id="resetDatasetSectorCount">
    UPDATE name_usage AS u SET dataset_sectors = NULL
    FROM name n
    WHERE u.dataset_key=#{datasetKey} AND n.dataset_key=#{datasetKey} AND n.id=u.name_id
      AND n.rank &lt; 'GENUS'
      AND NOT u.is_synonym
  </update>

</mapper>
